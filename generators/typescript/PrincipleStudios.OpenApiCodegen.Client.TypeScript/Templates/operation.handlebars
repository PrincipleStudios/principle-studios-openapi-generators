{{>partial_header Header}}
{{#with Operation}}
import type { HttpHeaders, AdapterRequestArgs, AdapterResponseArgs, RequestConversion, StandardResponse, TransformRequest } from '@principlestudios/openapi-codegen-typescript';
import { encodeURI, throwIfNullOrUndefined } from '@principlestudios/openapi-codegen-typescript';
{{#each Imports}}
import {
{{#each Members}}
    {{{.}}},
{{/each}}
} from '{{Path}}';
{{/each}}

export type UrlParams = {
    {{#each SharedParams}}
    {{#if IsUrlParam}}
    {{ParamName}}{{#unless Required}}?{{/unless}}: {{{DataType}}}{{#IsNullable}} | null{{/IsNullable}};
    {{/if}}
    {{/each}}
};
export type RequestParams = {
    {{#each SharedParams}}
    {{ParamName}}{{#unless Required}}?{{/unless}}: {{{DataType}}}{{#IsNullable}} | null{{/IsNullable}};
    {{/each}}
};
export type RequestBodies = {
    {{#each RequestBodies}}
    '{{RequestBodyType}}': {{#unless IsForm}}{{#each AllParams}}{{{DataType}}}{{#IsNullable}} | null{{/IsNullable}}{{/each}}{{else}}{
        {{#each AllParams}}
        {{ParamName}}{{#unless Required}}?{{/unless}}: {{{DataType}}}{{#IsNullable}} | null{{/IsNullable}};
        {{/each}}
    }{{/unless}};
    {{/each}}
};

export type StructuredResponses = {
    {{#if Responses.DefaultResponse}}
    {{#if Responses.DefaultResponse.Description}}
    /** {{Responses.DefaultResponse.Description}} */
    {{/if}}
    'other': {
        {{#each Responses.DefaultResponse.Content}}
        '{{MediaType}}': {{#if DataType}}{{{DataType}}}{{else}}undefined{{/if}};
        {{/each}}
    };
    {{/if}}
    {{#each Responses.StatusResponse as |Response StatusCode|}}
    {{#if Response.Description}}
    /** {{Response.Description}} */
    {{/if}}
    {{StatusCode}}: {
        {{#each Response.Content}}
        '{{MediaType}}': {{#if DataType}}{{{DataType}}}{{else}}undefined{{/if}};
        {{/each}}
    };
    {{/each}}
};
export type Responses = {{#if Responses.DefaultResponse}}{{#each Responses.DefaultResponse.Content}}
    | StandardResponse<'other', '{{MediaType}}', {{#if DataType}}{{{DataType}}}{{else}}undefined{{/if}}>{{/each}}{{/if}}{{!--
    --}}{{#each Responses.StatusResponse as |Response StatusCode|}}{{#each Response.Content}}
    | StandardResponse<{{StatusCode}}, '{{MediaType}}', {{#if DataType}}{{{DataType}}}{{else}}undefined{{/if}}>{{/each}}{{/each}};

export const method = '{{HttpMethod}}';
export const rawUrl = '{{{Path}}}';
export const callType = {{#if RequestBodies.length}}{{#unless AllowNoBody}}'body'{{else}}'optional'{{/unless}}{{else}}'no-body'{{/if}};

export function constructUrl(params: UrlParams): string {
    {{#if HasQueryParams}}
    const query = new URLSearchParams();
    {{#each SharedParams}}{{#if IsQueryParam}}
    {{#unless Required}}if (params.{{{ParamName}}} !== undefined)
        {{/unless}}{{#unless DataTypeEnumerable}}query.set('{{{RawName}}}', String(params.{{{ParamName}}}));{{else}}for (const value of params.{{{ParamName}}}) {
            query.append('{{{RawName}}}', String(value));
        }{{/unless}}
    {{/if}}{{/each}}

    {{/if}}
    return rawUrl{{#each SharedParams}}{{#if IsPathParam}}.replace('{{{RawNameWithCurly}}}', encodeURI(params.{{{ParamName}}})){{/if}}{{/each}}{{#if HasQueryParams}}
        + {{#if HasQueryInPath}}'&'{{else}}'?'{{/if}} + query.toString(){{/if}};
}

{{#if AllowNoBody}}
export function constructRequest(params: RequestParams): AdapterRequestArgs;
{{/if}}
{{#if RequestBodies.length}}
export function constructRequest<K extends keyof RequestBodies>(params: RequestParams, body: RequestBodies[K], mimeType: K): AdapterRequestArgs;
{{/if}}
export function constructRequest(params: RequestParams{{#if RequestBodies.length}}, body: RequestBodies[keyof RequestBodies] | null = null, mimeType: keyof RequestBodies | null = null{{/if}}): AdapterRequestArgs {
    throwIfNullOrUndefined(params, 'params');
    {{#if RequestBodies.length}}
    {{#if AllowNoBody}}if (mimeType) {{/if}}throwIfNullOrUndefined(body, 'body');
    {{#if AllowNoBody}}if (body)  {{/if}}throwIfNullOrUndefined(mimeType, 'mimeType');
    {{/if}}
    {{#each SharedParams}}
    {{#if Required}}
    throwIfNullOrUndefined(params.{{{ParamName}}}, '{{RawName}}');
    {{/if}}
    {{/each}}

    const headers: HttpHeaders = {};
    {{#if RequestBodies.length}}
    if (mimeType) headers['Content-Type'] = mimeType;
    {{/if}}
    {{#each SharedParams}}
    {{#if IsHeaderParam}}
    if (params.{{{ParamName}}} !== undefined) headers['{{{RawName}}}'] = params.{{{ParamName}}}; {{!-- TODO - openapi style/explode combo --}}
    {{/if}}
    {{/each}}

    {{#if HasFormRequest}}
    let formDataBody: RequestBodies[keyof RequestBodies] | FormData = body;
    if (mimeType === 'application/x-www-form-urlencoded')
    {
        let formData = new FormData();
        {{#each RequestBodies}}
        {{#each AllParams}}
        {{#if IsFormParam}}
        {{#if DataTypeEnumerable}}
        if (body!.{{{ParamName}}} !== undefined) {
            {{!-- TODO - openapi style/explode combo --}}
            body!.{{{ParamName}}}.forEach((element) => formData.append('{{RawName}}', element as any))
            {{!-- formData.append('{{RawName}}', body!.{{{ParamName}}}.join(COLLECTION_FORMATS['{{CollectionFormat}}'])); --}}
        }
        {{else}}
        if (body!.{{{ParamName}}} !== undefined) { formData.append('{{RawName}}', body!.{{{ParamName}}} as any); }
        {{/if}}
        {{/if}}
        {{/each}}
        {{/each}}
        formDataBody = formData;
    }

    {{/if}}
    return {
        path: constructUrl(params),
        method,
        headers,
        {{#if RequestBodies.length}}
        {{#if HasFormRequest}}
        body: formDataBody,
        {{else}}
        body,
        {{/if}}
        {{/if}}
    };
}

export function constructResponse(res: AdapterResponseArgs) {
    return ({
        statusCode: [{{#each Responses.StatusResponse as |Response StatusCode|}}
            {{StatusCode}},{{/each}}
        ].indexOf(res.status) === -1 ? 'other' : res.status,
        mimeType: res.getResponseHeader("Content-Type"),
        data: res.response,
        response: res,
        {{!-- TODO - we need response headers in this, etc. --}}
    }) as Responses;
}

export const conversion: RequestConversion<typeof method, UrlParams, RequestParams, {{#if RequestBodies.length}}RequestBodies{{else}}{}{{/if}}, Responses, typeof callType> = {
    method,
    url: constructUrl,
    callType,
    request: constructRequest,
    response: constructResponse,
};

{{/with}}
