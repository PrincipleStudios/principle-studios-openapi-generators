{{>partial_header header}}
#nullable enable
#nullable disable warnings
#pragma warning disable

namespace {{this.packageName}}
{ {{#with model as |model|}}{{#if Description}}
    /// <summary>
    /// {{linewrap Description "
    /// "}}
    /// </summary>{{/if}}
    [global::System.Text.Json.Serialization.JsonConverter(typeof({{ClassName}}.JsonConverter))]
    public partial record {{ClassName}}({{#each TypeEntries as |TypeEntry|}}
        {{{TypeEntry.TypeName}}}? {{{TypeEntry.Identifier}}} = null{{#unless @last}},{{/unless}}{{/each}}
    ) {

        public partial class JsonConverter : global::System.Text.Json.Serialization.JsonConverter<{{ClassName}}>
        {
{{!-- Adapted from https://github.com/jeremyVignelles/ooak/blob/bbc28d0dbde3093d1aff46ac6f8f23e006da9702/Ooak.SystemTextJson/OoakSystemTextJsonConverter.cs#L65 --}}
            public override {{ClassName}}? Read(ref global::System.Text.Json.Utf8JsonReader reader, global::System.Type typeToConvert, global::System.Text.Json.JsonSerializerOptions options)
            {
                var position = reader.BytesConsumed;
{{!-- TODO: check discriminator --}}
{{#each TypeEntries as |TypeEntry|}}

                {{{TypeEntry.TypeName}}} {{{TypeEntry.Identifier}}}Result = default;
                global::System.Exception? {{{TypeEntry.Identifier}}}Exception = null;
                global::System.Text.Json.Utf8JsonReader {{{TypeEntry.Identifier}}}Reader = reader;
                bool {{{TypeEntry.Identifier}}}IsValid;
                try
                {
                    {{{TypeEntry.Identifier}}}Result = global::System.Text.Json.JsonSerializer.Deserialize<{{{TypeEntry.TypeName}}}>(ref {{{TypeEntry.Identifier}}}Reader, options);
                    global::System.ComponentModel.DataAnnotations.Validator.ValidateObject(
                        {{{TypeEntry.Identifier}}}Result,
                        new global::System.ComponentModel.DataAnnotations.ValidationContext({{{TypeEntry.Identifier}}}Result)
                    );
                    {{{TypeEntry.Identifier}}}IsValid = true;
                }
                catch (global::System.Exception ex)
                {
                    {{{TypeEntry.Identifier}}}Result = default;
                    {{{TypeEntry.Identifier}}}Exception = ex;
                    {{{TypeEntry.Identifier}}}IsValid = false;
                }
{{/each}}

{{!-- TODO: check only OneOf or allow AnyOf --}}
                {{#each TypeEntries as |TypeEntry|}}
                if ({{{TypeEntry.Identifier}}}Exception == null)
                {
                    reader = {{{TypeEntry.Identifier}}}Reader;
                    return new {{ClassName}}({{{TypeEntry.Identifier}}}: {{{TypeEntry.Identifier}}}Result);
                }
                {{/each}}

                throw new global::System.Text.Json.JsonException(
                    "Unable to deserialize data as {{{ClassName}}} at position {{{position}}}",
                    new global::System.AggregateException({{#each TypeEntries as |TypeEntry|}}{{{TypeEntry.Identifier}}}Exception{{#unless @last}}, {{/unless}}{{/each}})
                );
            }

            public override void Write(global::System.Text.Json.Utf8JsonWriter writer, {{ClassName}} value, global::System.Text.Json.JsonSerializerOptions options)
            {
                var nodes = new[]
                {
{{!-- TODO: add discriminator if necessary --}}
{{#each TypeEntries as |TypeEntry|}}
                    value.{{{TypeEntry.Identifier}}} == null ? null : global::System.Text.Json.JsonSerializer.SerializeToNode<{{{TypeEntry.TypeName}}}>(value.{{{TypeEntry.Identifier}}}, options).AsObject(),
{{/each}}
                };
                var result = global::System.Linq.Enumerable.Aggregate(nodes, (prev, next) =>
                {
                    if (prev == null) return next;
                    if (next == null) return prev;
                    foreach (var (key, value) in next)
                    {
                        prev[key] = value;
                    }
                    return prev;
                });

                result.WriteTo(writer, options);
            }
        }
    }
{{/with}}
}