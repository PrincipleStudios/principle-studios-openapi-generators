/*
 * Swagger Petstore
 *
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@swagger.io
 * Generated by: https://principle.tools
 */
#nullable enable
#nullable disable warnings
#pragma warning disable

namespace PS.Controller
{ 
    public static class Operations
    {
        
        /// <summary>
        /// Add a new pet to the store
        /// </summary>
        /// <param name="addPetBody"></param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendAddPetAsync(
            this global::System.Net.Http.HttpClient client,
            Pet addPetBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(AddPet(addPetBody));

        public static global::System.Net.Http.HttpRequestMessage AddPet(
            Pet addPetBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/pet");
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(addPetBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IAddPetTypeSafeResult?> ParseAddPetTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 405:
                    
                        return new IAddPetTypeSafeResult.MethodNotAllowed
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface IAddPetTypeSafeResult
        {
            
            /// <summary>
            /// Invalid input
            /// </summary>
            public struct MethodNotAllowed : IAddPetTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Update an existing pet
        /// </summary>
        /// <param name="updatePetBody"></param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendUpdatePetAsync(
            this global::System.Net.Http.HttpClient client,
            Pet updatePetBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(UpdatePet(updatePetBody));

        public static global::System.Net.Http.HttpRequestMessage UpdatePet(
            Pet updatePetBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Put, "/pet");
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(updatePetBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IUpdatePetTypeSafeResult?> ParseUpdatePetTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 400:
                    
                        return new IUpdatePetTypeSafeResult.BadRequest
                        { 
                        };
                    break;
                
                case 404:
                    
                        return new IUpdatePetTypeSafeResult.NotFound
                        { 
                        };
                    break;
                
                case 405:
                    
                        return new IUpdatePetTypeSafeResult.MethodNotAllowed
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface IUpdatePetTypeSafeResult
        {
            
            /// <summary>
            /// Invalid ID supplied
            /// </summary>
            public struct BadRequest : IUpdatePetTypeSafeResult
            {
                
            }
            
            /// <summary>
            /// Pet not found
            /// </summary>
            public struct NotFound : IUpdatePetTypeSafeResult
            {
                
            }
            
            /// <summary>
            /// Validation exception
            /// </summary>
            public struct MethodNotAllowed : IUpdatePetTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Finds Pets by status
        /// </summary>
        /// <remarks>
        /// Multiple status values can be provided with comma separated strings
        /// </remarks>
        /// <param name="status">Status values that need to be considered for filter</param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendFindPetsByStatusAsync(
            this global::System.Net.Http.HttpClient client,
            global::System.Collections.Generic.IEnumerable<FindPetsByStatusStatusItem> status,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(FindPetsByStatus(status));

        public static global::System.Net.Http.HttpRequestMessage FindPetsByStatus(
            global::System.Collections.Generic.IEnumerable<FindPetsByStatusStatusItem> status
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/pet/findByStatus");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IFindPetsByStatusTypeSafeResult?> ParseFindPetsByStatusTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new IFindPetsByStatusTypeSafeResult.ApplicationJsonOk
                        { 
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<global::System.Collections.Generic.IEnumerable<Pet>>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new IFindPetsByStatusTypeSafeResult.BadRequest
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface IFindPetsByStatusTypeSafeResult
        {
            
            /// <summary>
            /// successful operation
            /// </summary>
            public struct ApplicationJsonOk : IFindPetsByStatusTypeSafeResult
            {
                public global::System.Collections.Generic.IEnumerable<Pet> Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid status value
            /// </summary>
            public struct BadRequest : IFindPetsByStatusTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Finds Pets by tags
        /// </summary>
        /// <remarks>
        /// Muliple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
        /// </remarks>
        /// <param name="tags">Tags to filter by</param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendFindPetsByTagsAsync(
            this global::System.Net.Http.HttpClient client,
            global::System.Collections.Generic.IEnumerable<string> tags,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(FindPetsByTags(tags));

        public static global::System.Net.Http.HttpRequestMessage FindPetsByTags(
            global::System.Collections.Generic.IEnumerable<string> tags
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/pet/findByTags");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IFindPetsByTagsTypeSafeResult?> ParseFindPetsByTagsTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new IFindPetsByTagsTypeSafeResult.ApplicationJsonOk
                        { 
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<global::System.Collections.Generic.IEnumerable<Pet>>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new IFindPetsByTagsTypeSafeResult.BadRequest
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface IFindPetsByTagsTypeSafeResult
        {
            
            /// <summary>
            /// successful operation
            /// </summary>
            public struct ApplicationJsonOk : IFindPetsByTagsTypeSafeResult
            {
                public global::System.Collections.Generic.IEnumerable<Pet> Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid tag value
            /// </summary>
            public struct BadRequest : IFindPetsByTagsTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Find pet by ID
        /// </summary>
        /// <remarks>
        /// Returns a single pet
        /// </remarks>
        /// <param name="petId">ID of pet to return</param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendGetPetByIdAsync(
            this global::System.Net.Http.HttpClient client,
            long petId,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(GetPetById(petId));

        public static global::System.Net.Http.HttpRequestMessage GetPetById(
            long petId
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/pet/{petId}"
                        .Replace("{" + "petId" + "}", global::System.Web.HttpUtility.UrlEncode(petId.ToString())));


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IGetPetByIdTypeSafeResult?> ParseGetPetByIdTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new IGetPetByIdTypeSafeResult.ApplicationJsonOk
                        { 
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<Pet>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new IGetPetByIdTypeSafeResult.BadRequest
                        { 
                        };
                    break;
                
                case 404:
                    
                        return new IGetPetByIdTypeSafeResult.NotFound
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface IGetPetByIdTypeSafeResult
        {
            
            /// <summary>
            /// successful operation
            /// </summary>
            public struct ApplicationJsonOk : IGetPetByIdTypeSafeResult
            {
                public Pet Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid ID supplied
            /// </summary>
            public struct BadRequest : IGetPetByIdTypeSafeResult
            {
                
            }
            
            /// <summary>
            /// Pet not found
            /// </summary>
            public struct NotFound : IGetPetByIdTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Updates a pet in the store with form data
        /// </summary>
        /// <param name="petId">ID of pet that needs to be updated</param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendUpdatePetWithFormAsync(
            this global::System.Net.Http.HttpClient client,
            long petId,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(UpdatePetWithForm(petId));

        public static global::System.Net.Http.HttpRequestMessage UpdatePetWithForm(
            long petId
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/pet/{petId}"
                        .Replace("{" + "petId" + "}", global::System.Web.HttpUtility.UrlEncode(petId.ToString())));


            return requestMessage;
        }


        /// <summary>
        /// Updates a pet in the store with form data
        /// </summary>
        /// <param name="petId">ID of pet that needs to be updated</param>
        /// <param name="name"></param>
        /// <param name="status"></param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendUpdatePetWithFormAsync(
            this global::System.Net.Http.HttpClient client,
            long petId,
string? name,
string? status,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(UpdatePetWithForm(petId,name,status));

        public static global::System.Net.Http.HttpRequestMessage UpdatePetWithForm(
            long petId,
            string? name,
            string? status
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/pet/{petId}"
                        .Replace("{" + "petId" + "}", global::System.Web.HttpUtility.UrlEncode(petId.ToString())));
            requestMessage.Content = new global::System.Net.Http.MultipartFormDataContent()
            {

                { new global::System.Net.Http.StringContent(name.ToString()), "name" },

                { new global::System.Net.Http.StringContent(status.ToString()), "status" },

            };


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IUpdatePetWithFormTypeSafeResult?> ParseUpdatePetWithFormTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 405:
                    
                        return new IUpdatePetWithFormTypeSafeResult.MethodNotAllowed
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface IUpdatePetWithFormTypeSafeResult
        {
            
            /// <summary>
            /// Invalid input
            /// </summary>
            public struct MethodNotAllowed : IUpdatePetWithFormTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Deletes a pet
        /// </summary>
        /// <param name="apiKey"></param>
        /// <param name="petId">Pet id to delete</param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendDeletePetAsync(
            this global::System.Net.Http.HttpClient client,
            string? apiKey,
long petId,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(DeletePet(apiKey,petId));

        public static global::System.Net.Http.HttpRequestMessage DeletePet(
            string? apiKey,
            long petId
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Delete, "/pet/{petId}"
                        .Replace("{" + "petId" + "}", global::System.Web.HttpUtility.UrlEncode(petId.ToString())));


            requestMessage.Headers.Add("", apiKey.ToString());
            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IDeletePetTypeSafeResult?> ParseDeletePetTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 400:
                    
                        return new IDeletePetTypeSafeResult.BadRequest
                        { 
                        };
                    break;
                
                case 404:
                    
                        return new IDeletePetTypeSafeResult.NotFound
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface IDeletePetTypeSafeResult
        {
            
            /// <summary>
            /// Invalid ID supplied
            /// </summary>
            public struct BadRequest : IDeletePetTypeSafeResult
            {
                
            }
            
            /// <summary>
            /// Pet not found
            /// </summary>
            public struct NotFound : IDeletePetTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// uploads an image
        /// </summary>
        /// <param name="petId">ID of pet to update</param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendUploadFileAsync(
            this global::System.Net.Http.HttpClient client,
            long petId,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(UploadFile(petId));

        public static global::System.Net.Http.HttpRequestMessage UploadFile(
            long petId
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/pet/{petId}/uploadImage"
                        .Replace("{" + "petId" + "}", global::System.Web.HttpUtility.UrlEncode(petId.ToString())));


            return requestMessage;
        }


        /// <summary>
        /// uploads an image
        /// </summary>
        /// <param name="petId">ID of pet to update</param>
        /// <param name="uploadFileBody"></param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendUploadFileAsync(
            this global::System.Net.Http.HttpClient client,
            long petId,
global::System.IO.Stream uploadFileBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(UploadFile(petId,uploadFileBody));

        public static global::System.Net.Http.HttpRequestMessage UploadFile(
            long petId,
            global::System.IO.Stream uploadFileBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/pet/{petId}/uploadImage"
                        .Replace("{" + "petId" + "}", global::System.Web.HttpUtility.UrlEncode(petId.ToString())));

            requestMessage.Content = new global::System.Net.Http.StreamContent(uploadFileBody);


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IUploadFileTypeSafeResult?> ParseUploadFileTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new IUploadFileTypeSafeResult.Ok
                        { 
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<ApiResponse>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
            }
            return null;
        }

        public interface IUploadFileTypeSafeResult
        {
            
            /// <summary>
            /// successful operation
            /// </summary>
            public struct Ok : IUploadFileTypeSafeResult
            {
                public ApiResponse Body { get; set; }
                
            }
            
        }

        /// <summary>
        /// Returns pet inventories by status
        /// </summary>
        /// <remarks>
        /// Returns a map of status codes to quantities
        /// </remarks>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendGetInventoryAsync(
            this global::System.Net.Http.HttpClient client,
                        global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(GetInventory());

        public static global::System.Net.Http.HttpRequestMessage GetInventory(
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/store/inventory");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IGetInventoryTypeSafeResult?> ParseGetInventoryTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new IGetInventoryTypeSafeResult.Ok
                        { 
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<global::System.Collections.Generic.Dictionary<string, int>>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
            }
            return null;
        }

        public interface IGetInventoryTypeSafeResult
        {
            
            /// <summary>
            /// successful operation
            /// </summary>
            public struct Ok : IGetInventoryTypeSafeResult
            {
                public global::System.Collections.Generic.Dictionary<string, int> Body { get; set; }
                
            }
            
        }

        /// <summary>
        /// Place an order for a pet
        /// </summary>
        /// <param name="placeOrderBody"></param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendPlaceOrderAsync(
            this global::System.Net.Http.HttpClient client,
            Order placeOrderBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(PlaceOrder(placeOrderBody));

        public static global::System.Net.Http.HttpRequestMessage PlaceOrder(
            Order placeOrderBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/store/order");
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(placeOrderBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IPlaceOrderTypeSafeResult?> ParsePlaceOrderTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new IPlaceOrderTypeSafeResult.ApplicationJsonOk
                        { 
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<Order>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new IPlaceOrderTypeSafeResult.BadRequest
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface IPlaceOrderTypeSafeResult
        {
            
            /// <summary>
            /// successful operation
            /// </summary>
            public struct ApplicationJsonOk : IPlaceOrderTypeSafeResult
            {
                public Order Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid Order
            /// </summary>
            public struct BadRequest : IPlaceOrderTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Find purchase order by ID
        /// </summary>
        /// <remarks>
        /// For valid response try integer IDs with value &gt;= 1 and &lt;= 10. Other values will generated exceptions
        /// </remarks>
        /// <param name="orderId">ID of pet that needs to be fetched</param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendGetOrderByIdAsync(
            this global::System.Net.Http.HttpClient client,
            long orderId,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(GetOrderById(orderId));

        public static global::System.Net.Http.HttpRequestMessage GetOrderById(
            long orderId
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/store/order/{orderId}"
                        .Replace("{" + "orderId" + "}", global::System.Web.HttpUtility.UrlEncode(orderId.ToString())));


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IGetOrderByIdTypeSafeResult?> ParseGetOrderByIdTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new IGetOrderByIdTypeSafeResult.ApplicationJsonOk
                        { 
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<Order>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new IGetOrderByIdTypeSafeResult.BadRequest
                        { 
                        };
                    break;
                
                case 404:
                    
                        return new IGetOrderByIdTypeSafeResult.NotFound
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface IGetOrderByIdTypeSafeResult
        {
            
            /// <summary>
            /// successful operation
            /// </summary>
            public struct ApplicationJsonOk : IGetOrderByIdTypeSafeResult
            {
                public Order Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid ID supplied
            /// </summary>
            public struct BadRequest : IGetOrderByIdTypeSafeResult
            {
                
            }
            
            /// <summary>
            /// Order not found
            /// </summary>
            public struct NotFound : IGetOrderByIdTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Delete purchase order by ID
        /// </summary>
        /// <remarks>
        /// For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors
        /// </remarks>
        /// <param name="orderId">ID of the order that needs to be deleted</param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendDeleteOrderAsync(
            this global::System.Net.Http.HttpClient client,
            long orderId,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(DeleteOrder(orderId));

        public static global::System.Net.Http.HttpRequestMessage DeleteOrder(
            long orderId
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Delete, "/store/order/{orderId}"
                        .Replace("{" + "orderId" + "}", global::System.Web.HttpUtility.UrlEncode(orderId.ToString())));


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IDeleteOrderTypeSafeResult?> ParseDeleteOrderTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 400:
                    
                        return new IDeleteOrderTypeSafeResult.BadRequest
                        { 
                        };
                    break;
                
                case 404:
                    
                        return new IDeleteOrderTypeSafeResult.NotFound
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface IDeleteOrderTypeSafeResult
        {
            
            /// <summary>
            /// Invalid ID supplied
            /// </summary>
            public struct BadRequest : IDeleteOrderTypeSafeResult
            {
                
            }
            
            /// <summary>
            /// Order not found
            /// </summary>
            public struct NotFound : IDeleteOrderTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Create user
        /// </summary>
        /// <remarks>
        /// This can only be done by the logged in user.
        /// </remarks>
        /// <param name="createUserBody"></param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendCreateUserAsync(
            this global::System.Net.Http.HttpClient client,
            User createUserBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(CreateUser(createUserBody));

        public static global::System.Net.Http.HttpRequestMessage CreateUser(
            User createUserBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/user");
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(createUserBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<ICreateUserTypeSafeResult?> ParseCreateUserTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                default: 
                    
                        return new ICreateUserTypeSafeResult.OtherStatusCode
                        { 
                        }; 
                    break;
            }
            return null;
        }

        public interface ICreateUserTypeSafeResult
        {
            
            
            public struct OtherStatusCode : ICreateUserTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Creates list of users with given input array
        /// </summary>
        /// <param name="createUsersWithArrayInputBody"></param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendCreateUsersWithArrayInputAsync(
            this global::System.Net.Http.HttpClient client,
            global::System.Collections.Generic.IEnumerable<User> createUsersWithArrayInputBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(CreateUsersWithArrayInput(createUsersWithArrayInputBody));

        public static global::System.Net.Http.HttpRequestMessage CreateUsersWithArrayInput(
            global::System.Collections.Generic.IEnumerable<User> createUsersWithArrayInputBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/user/createWithArray");
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(createUsersWithArrayInputBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<ICreateUsersWithArrayInputTypeSafeResult?> ParseCreateUsersWithArrayInputTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                default: 
                    
                        return new ICreateUsersWithArrayInputTypeSafeResult.OtherStatusCode
                        { 
                        }; 
                    break;
            }
            return null;
        }

        public interface ICreateUsersWithArrayInputTypeSafeResult
        {
            
            
            public struct OtherStatusCode : ICreateUsersWithArrayInputTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Creates list of users with given input array
        /// </summary>
        /// <param name="createUsersWithListInputBody"></param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendCreateUsersWithListInputAsync(
            this global::System.Net.Http.HttpClient client,
            global::System.Collections.Generic.IEnumerable<User> createUsersWithListInputBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(CreateUsersWithListInput(createUsersWithListInputBody));

        public static global::System.Net.Http.HttpRequestMessage CreateUsersWithListInput(
            global::System.Collections.Generic.IEnumerable<User> createUsersWithListInputBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/user/createWithList");
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(createUsersWithListInputBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<ICreateUsersWithListInputTypeSafeResult?> ParseCreateUsersWithListInputTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                default: 
                    
                        return new ICreateUsersWithListInputTypeSafeResult.OtherStatusCode
                        { 
                        }; 
                    break;
            }
            return null;
        }

        public interface ICreateUsersWithListInputTypeSafeResult
        {
            
            
            public struct OtherStatusCode : ICreateUsersWithListInputTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Logs user into the system
        /// </summary>
        /// <param name="username">The user name for login</param>
        /// <param name="password">The password for login in clear text</param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendLoginUserAsync(
            this global::System.Net.Http.HttpClient client,
            string username,
string password,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(LoginUser(username,password));

        public static global::System.Net.Http.HttpRequestMessage LoginUser(
            string username,
            string password
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/user/login");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<ILoginUserTypeSafeResult?> ParseLoginUserTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new ILoginUserTypeSafeResult.ApplicationJsonOk
                        { 
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<string>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new ILoginUserTypeSafeResult.BadRequest
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface ILoginUserTypeSafeResult
        {
            
            /// <summary>
            /// successful operation
            /// </summary>
            public struct ApplicationJsonOk : ILoginUserTypeSafeResult
            {
                public string Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid username/password supplied
            /// </summary>
            public struct BadRequest : ILoginUserTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Logs out current logged in user session
        /// </summary>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendLogoutUserAsync(
            this global::System.Net.Http.HttpClient client,
                        global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(LogoutUser());

        public static global::System.Net.Http.HttpRequestMessage LogoutUser(
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/user/logout");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<ILogoutUserTypeSafeResult?> ParseLogoutUserTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                default: 
                    
                        return new ILogoutUserTypeSafeResult.OtherStatusCode
                        { 
                        }; 
                    break;
            }
            return null;
        }

        public interface ILogoutUserTypeSafeResult
        {
            
            
            public struct OtherStatusCode : ILogoutUserTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Get user by user name
        /// </summary>
        /// <param name="username">The name that needs to be fetched. Use user1 for testing. </param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendGetUserByNameAsync(
            this global::System.Net.Http.HttpClient client,
            string username,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(GetUserByName(username));

        public static global::System.Net.Http.HttpRequestMessage GetUserByName(
            string username
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/user/{username}"
                        .Replace("{" + "username" + "}", global::System.Web.HttpUtility.UrlEncode(username.ToString())));


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IGetUserByNameTypeSafeResult?> ParseGetUserByNameTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new IGetUserByNameTypeSafeResult.ApplicationJsonOk
                        { 
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<User>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new IGetUserByNameTypeSafeResult.BadRequest
                        { 
                        };
                    break;
                
                case 404:
                    
                        return new IGetUserByNameTypeSafeResult.NotFound
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface IGetUserByNameTypeSafeResult
        {
            
            /// <summary>
            /// successful operation
            /// </summary>
            public struct ApplicationJsonOk : IGetUserByNameTypeSafeResult
            {
                public User Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid username supplied
            /// </summary>
            public struct BadRequest : IGetUserByNameTypeSafeResult
            {
                
            }
            
            /// <summary>
            /// User not found
            /// </summary>
            public struct NotFound : IGetUserByNameTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Updated user
        /// </summary>
        /// <remarks>
        /// This can only be done by the logged in user.
        /// </remarks>
        /// <param name="username">name that need to be updated</param>
        /// <param name="updateUserBody"></param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendUpdateUserAsync(
            this global::System.Net.Http.HttpClient client,
            string username,
User updateUserBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(UpdateUser(username,updateUserBody));

        public static global::System.Net.Http.HttpRequestMessage UpdateUser(
            string username,
            User updateUserBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Put, "/user/{username}"
                        .Replace("{" + "username" + "}", global::System.Web.HttpUtility.UrlEncode(username.ToString())));
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(updateUserBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IUpdateUserTypeSafeResult?> ParseUpdateUserTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 400:
                    
                        return new IUpdateUserTypeSafeResult.BadRequest
                        { 
                        };
                    break;
                
                case 404:
                    
                        return new IUpdateUserTypeSafeResult.NotFound
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface IUpdateUserTypeSafeResult
        {
            
            /// <summary>
            /// Invalid user supplied
            /// </summary>
            public struct BadRequest : IUpdateUserTypeSafeResult
            {
                
            }
            
            /// <summary>
            /// User not found
            /// </summary>
            public struct NotFound : IUpdateUserTypeSafeResult
            {
                
            }
            
        }

        /// <summary>
        /// Delete user
        /// </summary>
        /// <remarks>
        /// This can only be done by the logged in user.
        /// </remarks>
        /// <param name="username">The name that needs to be deleted</param>
        public static global::System.Threading.Tasks.Task<global::System.Net.Http.HttpResponseMessage> SendDeleteUserAsync(
            this global::System.Net.Http.HttpClient client,
            string username,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => client.SendAsync(DeleteUser(username));

        public static global::System.Net.Http.HttpRequestMessage DeleteUser(
            string username
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Delete, "/user/{username}"
                        .Replace("{" + "username" + "}", global::System.Web.HttpUtility.UrlEncode(username.ToString())));


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<IDeleteUserTypeSafeResult?> ParseDeleteUserTypeSafe(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 400:
                    
                        return new IDeleteUserTypeSafeResult.BadRequest
                        { 
                        };
                    break;
                
                case 404:
                    
                        return new IDeleteUserTypeSafeResult.NotFound
                        { 
                        };
                    break;
                
            }
            return null;
        }

        public interface IDeleteUserTypeSafeResult
        {
            
            /// <summary>
            /// Invalid username supplied
            /// </summary>
            public struct BadRequest : IDeleteUserTypeSafeResult
            {
                
            }
            
            /// <summary>
            /// User not found
            /// </summary>
            public struct NotFound : IDeleteUserTypeSafeResult
            {
                
            }
            
        }
    }
}
