/*
 * Swagger Petstore
 *
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@swagger.io
 * Generated by: https://principle.tools
 */
#nullable enable
#nullable disable warnings
#pragma warning disable

namespace PS.Controller
{ 
    public static class Operations
    {
        
        /// <summary>
        /// Add a new pet to the store
        /// </summary>
        /// <param name="addPetBody"></param>
        public static async global::System.Threading.Tasks.Task<AddPetReturnType> AddPet(
            this global::System.Net.Http.HttpClient client,
            Pet addPetBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(AddPet(addPetBody)).ConfigureAwait(false))
            .ParseAddPet().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage AddPet(
            Pet addPetBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/pet");
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(addPetBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<AddPetReturnType?> ParseAddPet(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 405:
                    
                        return new AddPetReturnType.MethodNotAllowed
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new AddPetReturnType
            {
                Response = response,
            };
        }

        public class AddPetReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// Invalid input
            /// </summary>
            public class MethodNotAllowed : AddPetReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Update an existing pet
        /// </summary>
        /// <param name="updatePetBody"></param>
        public static async global::System.Threading.Tasks.Task<UpdatePetReturnType> UpdatePet(
            this global::System.Net.Http.HttpClient client,
            Pet updatePetBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(UpdatePet(updatePetBody)).ConfigureAwait(false))
            .ParseUpdatePet().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage UpdatePet(
            Pet updatePetBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Put, "/pet");
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(updatePetBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<UpdatePetReturnType?> ParseUpdatePet(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 400:
                    
                        return new UpdatePetReturnType.BadRequest
                        {
                            Response = response,
                        };
                    break;
                
                case 404:
                    
                        return new UpdatePetReturnType.NotFound
                        {
                            Response = response,
                        };
                    break;
                
                case 405:
                    
                        return new UpdatePetReturnType.MethodNotAllowed
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new UpdatePetReturnType
            {
                Response = response,
            };
        }

        public class UpdatePetReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// Invalid ID supplied
            /// </summary>
            public class BadRequest : UpdatePetReturnType
            {
                
            }
            
            /// <summary>
            /// Pet not found
            /// </summary>
            public class NotFound : UpdatePetReturnType
            {
                
            }
            
            /// <summary>
            /// Validation exception
            /// </summary>
            public class MethodNotAllowed : UpdatePetReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Finds Pets by status
        /// </summary>
        /// <remarks>
        /// Multiple status values can be provided with comma separated strings
        /// </remarks>
        /// <param name="status">Status values that need to be considered for filter</param>
        public static async global::System.Threading.Tasks.Task<FindPetsByStatusReturnType> FindPetsByStatus(
            this global::System.Net.Http.HttpClient client,
            global::System.Collections.Generic.IEnumerable<FindPetsByStatusStatusItem> status,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(FindPetsByStatus(status)).ConfigureAwait(false))
            .ParseFindPetsByStatus().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage FindPetsByStatus(
            global::System.Collections.Generic.IEnumerable<FindPetsByStatusStatusItem> status
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/pet/findByStatus");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<FindPetsByStatusReturnType?> ParseFindPetsByStatus(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new FindPetsByStatusReturnType.ApplicationJsonOk
                        {
                            Response = response,
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<global::System.Collections.Generic.IEnumerable<Pet>>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new FindPetsByStatusReturnType.BadRequest
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new FindPetsByStatusReturnType
            {
                Response = response,
            };
        }

        public class FindPetsByStatusReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// successful operation
            /// </summary>
            public class ApplicationJsonOk : FindPetsByStatusReturnType
            {
                public global::System.Collections.Generic.IEnumerable<Pet> Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid status value
            /// </summary>
            public class BadRequest : FindPetsByStatusReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Finds Pets by tags
        /// </summary>
        /// <remarks>
        /// Muliple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
        /// </remarks>
        /// <param name="tags">Tags to filter by</param>
        public static async global::System.Threading.Tasks.Task<FindPetsByTagsReturnType> FindPetsByTags(
            this global::System.Net.Http.HttpClient client,
            global::System.Collections.Generic.IEnumerable<string> tags,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(FindPetsByTags(tags)).ConfigureAwait(false))
            .ParseFindPetsByTags().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage FindPetsByTags(
            global::System.Collections.Generic.IEnumerable<string> tags
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/pet/findByTags");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<FindPetsByTagsReturnType?> ParseFindPetsByTags(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new FindPetsByTagsReturnType.ApplicationJsonOk
                        {
                            Response = response,
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<global::System.Collections.Generic.IEnumerable<Pet>>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new FindPetsByTagsReturnType.BadRequest
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new FindPetsByTagsReturnType
            {
                Response = response,
            };
        }

        public class FindPetsByTagsReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// successful operation
            /// </summary>
            public class ApplicationJsonOk : FindPetsByTagsReturnType
            {
                public global::System.Collections.Generic.IEnumerable<Pet> Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid tag value
            /// </summary>
            public class BadRequest : FindPetsByTagsReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Find pet by ID
        /// </summary>
        /// <remarks>
        /// Returns a single pet
        /// </remarks>
        /// <param name="petId">ID of pet to return</param>
        public static async global::System.Threading.Tasks.Task<GetPetByIdReturnType> GetPetById(
            this global::System.Net.Http.HttpClient client,
            long petId,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(GetPetById(petId)).ConfigureAwait(false))
            .ParseGetPetById().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage GetPetById(
            long petId
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/pet/{petId}"
                        .Replace("{" + "petId" + "}", global::System.Web.HttpUtility.UrlEncode(petId.ToString())));


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<GetPetByIdReturnType?> ParseGetPetById(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new GetPetByIdReturnType.ApplicationJsonOk
                        {
                            Response = response,
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<Pet>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new GetPetByIdReturnType.BadRequest
                        {
                            Response = response,
                        };
                    break;
                
                case 404:
                    
                        return new GetPetByIdReturnType.NotFound
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new GetPetByIdReturnType
            {
                Response = response,
            };
        }

        public class GetPetByIdReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// successful operation
            /// </summary>
            public class ApplicationJsonOk : GetPetByIdReturnType
            {
                public Pet Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid ID supplied
            /// </summary>
            public class BadRequest : GetPetByIdReturnType
            {
                
            }
            
            /// <summary>
            /// Pet not found
            /// </summary>
            public class NotFound : GetPetByIdReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Updates a pet in the store with form data
        /// </summary>
        /// <param name="petId">ID of pet that needs to be updated</param>
        public static async global::System.Threading.Tasks.Task<UpdatePetWithFormReturnType> UpdatePetWithForm(
            this global::System.Net.Http.HttpClient client,
            long petId,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(UpdatePetWithForm(petId)).ConfigureAwait(false))
            .ParseUpdatePetWithForm().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage UpdatePetWithForm(
            long petId
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/pet/{petId}"
                        .Replace("{" + "petId" + "}", global::System.Web.HttpUtility.UrlEncode(petId.ToString())));


            return requestMessage;
        }


        /// <summary>
        /// Updates a pet in the store with form data
        /// </summary>
        /// <param name="petId">ID of pet that needs to be updated</param>
        /// <param name="name"></param>
        /// <param name="status"></param>
        public static async global::System.Threading.Tasks.Task<UpdatePetWithFormReturnType> UpdatePetWithForm(
            this global::System.Net.Http.HttpClient client,
            long petId,
string? name,
string? status,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(UpdatePetWithForm(petId,name,status)).ConfigureAwait(false))
            .ParseUpdatePetWithForm().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage UpdatePetWithForm(
            long petId,
            string? name,
            string? status
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/pet/{petId}"
                        .Replace("{" + "petId" + "}", global::System.Web.HttpUtility.UrlEncode(petId.ToString())));
            requestMessage.Content = new global::System.Net.Http.MultipartFormDataContent()
            {

                { new global::System.Net.Http.StringContent(name.ToString()), "name" },

                { new global::System.Net.Http.StringContent(status.ToString()), "status" },

            };


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<UpdatePetWithFormReturnType?> ParseUpdatePetWithForm(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 405:
                    
                        return new UpdatePetWithFormReturnType.MethodNotAllowed
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new UpdatePetWithFormReturnType
            {
                Response = response,
            };
        }

        public class UpdatePetWithFormReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// Invalid input
            /// </summary>
            public class MethodNotAllowed : UpdatePetWithFormReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Deletes a pet
        /// </summary>
        /// <param name="apiKey"></param>
        /// <param name="petId">Pet id to delete</param>
        public static async global::System.Threading.Tasks.Task<DeletePetReturnType> DeletePet(
            this global::System.Net.Http.HttpClient client,
            string? apiKey,
long petId,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(DeletePet(apiKey,petId)).ConfigureAwait(false))
            .ParseDeletePet().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage DeletePet(
            string? apiKey,
            long petId
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Delete, "/pet/{petId}"
                        .Replace("{" + "petId" + "}", global::System.Web.HttpUtility.UrlEncode(petId.ToString())));


            requestMessage.Headers.Add("", apiKey.ToString());
            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<DeletePetReturnType?> ParseDeletePet(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 400:
                    
                        return new DeletePetReturnType.BadRequest
                        {
                            Response = response,
                        };
                    break;
                
                case 404:
                    
                        return new DeletePetReturnType.NotFound
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new DeletePetReturnType
            {
                Response = response,
            };
        }

        public class DeletePetReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// Invalid ID supplied
            /// </summary>
            public class BadRequest : DeletePetReturnType
            {
                
            }
            
            /// <summary>
            /// Pet not found
            /// </summary>
            public class NotFound : DeletePetReturnType
            {
                
            }
            
        }

        /// <summary>
        /// uploads an image
        /// </summary>
        /// <param name="petId">ID of pet to update</param>
        public static async global::System.Threading.Tasks.Task<UploadFileReturnType> UploadFile(
            this global::System.Net.Http.HttpClient client,
            long petId,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(UploadFile(petId)).ConfigureAwait(false))
            .ParseUploadFile().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage UploadFile(
            long petId
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/pet/{petId}/uploadImage"
                        .Replace("{" + "petId" + "}", global::System.Web.HttpUtility.UrlEncode(petId.ToString())));


            return requestMessage;
        }


        /// <summary>
        /// uploads an image
        /// </summary>
        /// <param name="petId">ID of pet to update</param>
        /// <param name="uploadFileBody"></param>
        public static async global::System.Threading.Tasks.Task<UploadFileReturnType> UploadFile(
            this global::System.Net.Http.HttpClient client,
            long petId,
global::System.IO.Stream uploadFileBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(UploadFile(petId,uploadFileBody)).ConfigureAwait(false))
            .ParseUploadFile().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage UploadFile(
            long petId,
            global::System.IO.Stream uploadFileBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/pet/{petId}/uploadImage"
                        .Replace("{" + "petId" + "}", global::System.Web.HttpUtility.UrlEncode(petId.ToString())));

            requestMessage.Content = new global::System.Net.Http.StreamContent(uploadFileBody);


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<UploadFileReturnType?> ParseUploadFile(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new UploadFileReturnType.Ok
                        {
                            Response = response,
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<ApiResponse>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
            }
            return new UploadFileReturnType
            {
                Response = response,
            };
        }

        public class UploadFileReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// successful operation
            /// </summary>
            public class Ok : UploadFileReturnType
            {
                public ApiResponse Body { get; set; }
                
            }
            
        }

        /// <summary>
        /// Returns pet inventories by status
        /// </summary>
        /// <remarks>
        /// Returns a map of status codes to quantities
        /// </remarks>
        public static async global::System.Threading.Tasks.Task<GetInventoryReturnType> GetInventory(
            this global::System.Net.Http.HttpClient client,
                        global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(GetInventory()).ConfigureAwait(false))
            .ParseGetInventory().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage GetInventory(
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/store/inventory");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<GetInventoryReturnType?> ParseGetInventory(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new GetInventoryReturnType.Ok
                        {
                            Response = response,
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<global::System.Collections.Generic.Dictionary<string, int>>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
            }
            return new GetInventoryReturnType
            {
                Response = response,
            };
        }

        public class GetInventoryReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// successful operation
            /// </summary>
            public class Ok : GetInventoryReturnType
            {
                public global::System.Collections.Generic.Dictionary<string, int> Body { get; set; }
                
            }
            
        }

        /// <summary>
        /// Place an order for a pet
        /// </summary>
        /// <param name="placeOrderBody"></param>
        public static async global::System.Threading.Tasks.Task<PlaceOrderReturnType> PlaceOrder(
            this global::System.Net.Http.HttpClient client,
            Order placeOrderBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(PlaceOrder(placeOrderBody)).ConfigureAwait(false))
            .ParsePlaceOrder().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage PlaceOrder(
            Order placeOrderBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/store/order");
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(placeOrderBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<PlaceOrderReturnType?> ParsePlaceOrder(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new PlaceOrderReturnType.ApplicationJsonOk
                        {
                            Response = response,
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<Order>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new PlaceOrderReturnType.BadRequest
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new PlaceOrderReturnType
            {
                Response = response,
            };
        }

        public class PlaceOrderReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// successful operation
            /// </summary>
            public class ApplicationJsonOk : PlaceOrderReturnType
            {
                public Order Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid Order
            /// </summary>
            public class BadRequest : PlaceOrderReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Find purchase order by ID
        /// </summary>
        /// <remarks>
        /// For valid response try integer IDs with value &gt;= 1 and &lt;= 10. Other values will generated exceptions
        /// </remarks>
        /// <param name="orderId">ID of pet that needs to be fetched</param>
        public static async global::System.Threading.Tasks.Task<GetOrderByIdReturnType> GetOrderById(
            this global::System.Net.Http.HttpClient client,
            long orderId,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(GetOrderById(orderId)).ConfigureAwait(false))
            .ParseGetOrderById().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage GetOrderById(
            long orderId
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/store/order/{orderId}"
                        .Replace("{" + "orderId" + "}", global::System.Web.HttpUtility.UrlEncode(orderId.ToString())));


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<GetOrderByIdReturnType?> ParseGetOrderById(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new GetOrderByIdReturnType.ApplicationJsonOk
                        {
                            Response = response,
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<Order>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new GetOrderByIdReturnType.BadRequest
                        {
                            Response = response,
                        };
                    break;
                
                case 404:
                    
                        return new GetOrderByIdReturnType.NotFound
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new GetOrderByIdReturnType
            {
                Response = response,
            };
        }

        public class GetOrderByIdReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// successful operation
            /// </summary>
            public class ApplicationJsonOk : GetOrderByIdReturnType
            {
                public Order Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid ID supplied
            /// </summary>
            public class BadRequest : GetOrderByIdReturnType
            {
                
            }
            
            /// <summary>
            /// Order not found
            /// </summary>
            public class NotFound : GetOrderByIdReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Delete purchase order by ID
        /// </summary>
        /// <remarks>
        /// For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors
        /// </remarks>
        /// <param name="orderId">ID of the order that needs to be deleted</param>
        public static async global::System.Threading.Tasks.Task<DeleteOrderReturnType> DeleteOrder(
            this global::System.Net.Http.HttpClient client,
            long orderId,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(DeleteOrder(orderId)).ConfigureAwait(false))
            .ParseDeleteOrder().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage DeleteOrder(
            long orderId
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Delete, "/store/order/{orderId}"
                        .Replace("{" + "orderId" + "}", global::System.Web.HttpUtility.UrlEncode(orderId.ToString())));


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<DeleteOrderReturnType?> ParseDeleteOrder(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 400:
                    
                        return new DeleteOrderReturnType.BadRequest
                        {
                            Response = response,
                        };
                    break;
                
                case 404:
                    
                        return new DeleteOrderReturnType.NotFound
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new DeleteOrderReturnType
            {
                Response = response,
            };
        }

        public class DeleteOrderReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// Invalid ID supplied
            /// </summary>
            public class BadRequest : DeleteOrderReturnType
            {
                
            }
            
            /// <summary>
            /// Order not found
            /// </summary>
            public class NotFound : DeleteOrderReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Create user
        /// </summary>
        /// <remarks>
        /// This can only be done by the logged in user.
        /// </remarks>
        /// <param name="createUserBody"></param>
        public static async global::System.Threading.Tasks.Task<CreateUserReturnType> CreateUser(
            this global::System.Net.Http.HttpClient client,
            User createUserBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(CreateUser(createUserBody)).ConfigureAwait(false))
            .ParseCreateUser().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage CreateUser(
            User createUserBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/user");
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(createUserBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<CreateUserReturnType?> ParseCreateUser(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                default: 
                    
                        return new CreateUserReturnType.OtherStatusCode
                        {
                            Response = response,
                        }; 
                    break;
            }
            return new CreateUserReturnType
            {
                Response = response,
            };
        }

        public class CreateUserReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            
            public class OtherStatusCode : CreateUserReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Creates list of users with given input array
        /// </summary>
        /// <param name="createUsersWithArrayInputBody"></param>
        public static async global::System.Threading.Tasks.Task<CreateUsersWithArrayInputReturnType> CreateUsersWithArrayInput(
            this global::System.Net.Http.HttpClient client,
            global::System.Collections.Generic.IEnumerable<User> createUsersWithArrayInputBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(CreateUsersWithArrayInput(createUsersWithArrayInputBody)).ConfigureAwait(false))
            .ParseCreateUsersWithArrayInput().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage CreateUsersWithArrayInput(
            global::System.Collections.Generic.IEnumerable<User> createUsersWithArrayInputBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/user/createWithArray");
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(createUsersWithArrayInputBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<CreateUsersWithArrayInputReturnType?> ParseCreateUsersWithArrayInput(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                default: 
                    
                        return new CreateUsersWithArrayInputReturnType.OtherStatusCode
                        {
                            Response = response,
                        }; 
                    break;
            }
            return new CreateUsersWithArrayInputReturnType
            {
                Response = response,
            };
        }

        public class CreateUsersWithArrayInputReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            
            public class OtherStatusCode : CreateUsersWithArrayInputReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Creates list of users with given input array
        /// </summary>
        /// <param name="createUsersWithListInputBody"></param>
        public static async global::System.Threading.Tasks.Task<CreateUsersWithListInputReturnType> CreateUsersWithListInput(
            this global::System.Net.Http.HttpClient client,
            global::System.Collections.Generic.IEnumerable<User> createUsersWithListInputBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(CreateUsersWithListInput(createUsersWithListInputBody)).ConfigureAwait(false))
            .ParseCreateUsersWithListInput().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage CreateUsersWithListInput(
            global::System.Collections.Generic.IEnumerable<User> createUsersWithListInputBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Post, "/user/createWithList");
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(createUsersWithListInputBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<CreateUsersWithListInputReturnType?> ParseCreateUsersWithListInput(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                default: 
                    
                        return new CreateUsersWithListInputReturnType.OtherStatusCode
                        {
                            Response = response,
                        }; 
                    break;
            }
            return new CreateUsersWithListInputReturnType
            {
                Response = response,
            };
        }

        public class CreateUsersWithListInputReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            
            public class OtherStatusCode : CreateUsersWithListInputReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Logs user into the system
        /// </summary>
        /// <param name="username">The user name for login</param>
        /// <param name="password">The password for login in clear text</param>
        public static async global::System.Threading.Tasks.Task<LoginUserReturnType> LoginUser(
            this global::System.Net.Http.HttpClient client,
            string username,
string password,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(LoginUser(username,password)).ConfigureAwait(false))
            .ParseLoginUser().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage LoginUser(
            string username,
            string password
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/user/login");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<LoginUserReturnType?> ParseLoginUser(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new LoginUserReturnType.ApplicationJsonOk
                        {
                            Response = response,
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<string>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new LoginUserReturnType.BadRequest
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new LoginUserReturnType
            {
                Response = response,
            };
        }

        public class LoginUserReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// successful operation
            /// </summary>
            public class ApplicationJsonOk : LoginUserReturnType
            {
                public string Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid username/password supplied
            /// </summary>
            public class BadRequest : LoginUserReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Logs out current logged in user session
        /// </summary>
        public static async global::System.Threading.Tasks.Task<LogoutUserReturnType> LogoutUser(
            this global::System.Net.Http.HttpClient client,
                        global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(LogoutUser()).ConfigureAwait(false))
            .ParseLogoutUser().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage LogoutUser(
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/user/logout");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<LogoutUserReturnType?> ParseLogoutUser(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                default: 
                    
                        return new LogoutUserReturnType.OtherStatusCode
                        {
                            Response = response,
                        }; 
                    break;
            }
            return new LogoutUserReturnType
            {
                Response = response,
            };
        }

        public class LogoutUserReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            
            public class OtherStatusCode : LogoutUserReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Get user by user name
        /// </summary>
        /// <param name="username">The name that needs to be fetched. Use user1 for testing. </param>
        public static async global::System.Threading.Tasks.Task<GetUserByNameReturnType> GetUserByName(
            this global::System.Net.Http.HttpClient client,
            string username,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(GetUserByName(username)).ConfigureAwait(false))
            .ParseGetUserByName().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage GetUserByName(
            string username
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Get, "/user/{username}"
                        .Replace("{" + "username" + "}", global::System.Web.HttpUtility.UrlEncode(username.ToString())));


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<GetUserByNameReturnType?> ParseGetUserByName(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 200:
                     if (response.Content.Headers.ContentType.MediaType == "application/json") 
                        return new GetUserByNameReturnType.ApplicationJsonOk
                        {
                            Response = response,
                            Body = Newtonsoft.Json.JsonConvert.DeserializeObject<User>(await response.Content.ReadAsStringAsync()), 
                        };
                    break;
                
                case 400:
                    
                        return new GetUserByNameReturnType.BadRequest
                        {
                            Response = response,
                        };
                    break;
                
                case 404:
                    
                        return new GetUserByNameReturnType.NotFound
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new GetUserByNameReturnType
            {
                Response = response,
            };
        }

        public class GetUserByNameReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// successful operation
            /// </summary>
            public class ApplicationJsonOk : GetUserByNameReturnType
            {
                public User Body { get; set; }
                
            }
            
            /// <summary>
            /// Invalid username supplied
            /// </summary>
            public class BadRequest : GetUserByNameReturnType
            {
                
            }
            
            /// <summary>
            /// User not found
            /// </summary>
            public class NotFound : GetUserByNameReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Updated user
        /// </summary>
        /// <remarks>
        /// This can only be done by the logged in user.
        /// </remarks>
        /// <param name="username">name that need to be updated</param>
        /// <param name="updateUserBody"></param>
        public static async global::System.Threading.Tasks.Task<UpdateUserReturnType> UpdateUser(
            this global::System.Net.Http.HttpClient client,
            string username,
User updateUserBody,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(UpdateUser(username,updateUserBody)).ConfigureAwait(false))
            .ParseUpdateUser().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage UpdateUser(
            string username,
            User updateUserBody
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Put, "/user/{username}"
                        .Replace("{" + "username" + "}", global::System.Web.HttpUtility.UrlEncode(username.ToString())));
            requestMessage.Content = new global::System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(updateUserBody), System.Text.Encoding.UTF8, "application/json");


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<UpdateUserReturnType?> ParseUpdateUser(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 400:
                    
                        return new UpdateUserReturnType.BadRequest
                        {
                            Response = response,
                        };
                    break;
                
                case 404:
                    
                        return new UpdateUserReturnType.NotFound
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new UpdateUserReturnType
            {
                Response = response,
            };
        }

        public class UpdateUserReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// Invalid user supplied
            /// </summary>
            public class BadRequest : UpdateUserReturnType
            {
                
            }
            
            /// <summary>
            /// User not found
            /// </summary>
            public class NotFound : UpdateUserReturnType
            {
                
            }
            
        }

        /// <summary>
        /// Delete user
        /// </summary>
        /// <remarks>
        /// This can only be done by the logged in user.
        /// </remarks>
        /// <param name="username">The name that needs to be deleted</param>
        public static async global::System.Threading.Tasks.Task<DeleteUserReturnType> DeleteUser(
            this global::System.Net.Http.HttpClient client,
            string username,
            global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)
        ) => await (await client.SendAsync(DeleteUser(username)).ConfigureAwait(false))
            .ParseDeleteUser().ConfigureAwait(false);

        public static global::System.Net.Http.HttpRequestMessage DeleteUser(
            string username
            )
        {
            var requestMessage = new global::System.Net.Http.HttpRequestMessage(global::System.Net.Http.HttpMethod.Delete, "/user/{username}"
                        .Replace("{" + "username" + "}", global::System.Web.HttpUtility.UrlEncode(username.ToString())));


            return requestMessage;
        }

        public static async global::System.Threading.Tasks.Task<DeleteUserReturnType?> ParseDeleteUser(this global::System.Net.Http.HttpResponseMessage response)
        {
            switch ((int)response.StatusCode)
            { 
                case 400:
                    
                        return new DeleteUserReturnType.BadRequest
                        {
                            Response = response,
                        };
                    break;
                
                case 404:
                    
                        return new DeleteUserReturnType.NotFound
                        {
                            Response = response,
                        };
                    break;
                
            }
            return new DeleteUserReturnType
            {
                Response = response,
            };
        }

        public class DeleteUserReturnType : global::System.IDisposable
        {
            public global::System.Net.Http.HttpResponseMessage Response { get; set; }

            void global::System.IDisposable.Dispose()
            {
                Response?.Dispose();
            }

            
            /// <summary>
            /// Invalid username supplied
            /// </summary>
            public class BadRequest : DeleteUserReturnType
            {
                
            }
            
            /// <summary>
            /// User not found
            /// </summary>
            public class NotFound : DeleteUserReturnType
            {
                
            }
            
        }
    }
}
